# EDL Backend CLI Cheat Sheet

## 1. Admin environment & server start
# Run in the PowerShell session that will host Uvicorn.
# Core auth keys
# EDL_API_KEY acts as the bootstrap super-admin key. Once you provision managed admin accounts,
# you can rotate it away.
$env:EDL_API_KEY        = 'super-secret-key'   # optional bootstrap super-admin key
$env:EDL_OPERATOR_KEYS  = 'super-secret-key'   # optional comma-separated legacy operator keys
$env:EDL_READER_KEYS    = ''                   # optional comma-separated read-only keys

# Scheduler defaults (override per environment)
$env:EDL_AUTO_REFRESH_MINUTES           = '5'  # scheduler wake interval
$env:EDL_MAX_CONCURRENT_RUNS_TOTAL      = '10'
$env:EDL_MAX_CONCURRENT_RUNS_PER_PROFILE = '3'

# Optional database overrides
# $env:DATABASE_URL     = 'postgresql://user:pass@host:5432/dbname'
# $env:SQLITE_PATH      = 'C:\path\to\custom.db'
# $env:SQL_ECHO         = '1'   # SQLAlchemy echo logs
# $env:DB_POOL_SIZE     = '10'
# $env:DB_MAX_OVERFLOW  = '20'
# $env:DB_POOL_RECYCLE  = '1800'
# $env:DB_RETRY_DELAY   = '2.0'

# Scheduler-concurrency overrides
# $env:EDL_MAX_CONCURRENT_RUNS_TOTAL      = '20'
# $env:EDL_MAX_CONCURRENT_RUNS_PER_PROFILE = '5'

# Pipeline execution tuning
# $env:EDL_MAX_RUN_QUEUE               = '50'   # hypothetical queue cap
# $env:EDL_RUN_BACKPRESSURE_SECONDS    = '5'
# $env:EDL_RUN_CANCEL_GRACE_SECONDS    = '30'

# Hosted feed customization
# $env:EDL_HOSTED_LOG_DIR = 'logs'      # directory where engine logs/feeds live
# $env:EDL_HOSTED_LOG_PREFIX = 'engine.log'

# Launch FastAPI (no reload; adjust port if 8000 is free again)
uvicorn api.main:app --host 0.0.0.0 --port 8100

## 1b. Provision managed admin accounts (super-admin key required)
$baseUrl = 'http://localhost:8100'
$rootHeaders = @{
    'X-API-Key'    = 'super-secret-key'  # bootstrap super-admin key
    'Content-Type' = 'application/json'
}

$adminPayload = @{
    name  = 'Operations Admin'
    role  = 'operator'  # or 'reader'
} | ConvertTo-Json -Depth 3

$adminResponse = Invoke-RestMethod `
    -Method Post `
    -Uri "$baseUrl/admin/accounts" `
    -Headers $rootHeaders `
    -Body ([Text.Encoding]::UTF8.GetBytes($adminPayload))

$opsAdminId  = $adminResponse.id
$opsAdminKey = $adminResponse.api_key

## 2. Create a profile (admin/operator key required)
# Response returns the tenant's API key once; save both id and api_key.
Invoke-RestMethod `
    -Method Post `
    -Uri "$baseUrl/profiles" ` # Super admins can append ?owner_admin_id=$opsAdminId to assign ownership when creating on behalf of another admin.
    -Headers @{
        'X-API-Key'    = $opsAdminKey
        'Content-Type' = 'application/json'
    } `
    -Body '{"name":"Acme SOC","description":"Tier-1 security operations"}'

## 3. Tenant-scoped variables (replace with values from the response)
$profileId  = '8e6b47c8-3bef-460f-aea4-a34f81651c8d'
$profileKey = 'wfyPOwnv5PHYfRWwgPFi9bRH1rpmZUdZnfEBCbYNTX8'
$baseUrl    = 'http://localhost:8100'

$headers = @{
    'Content-Type' = 'application/json; charset=utf-8'
    'X-API-Key'    = $profileKey
}

## 4. Create a profile config (augment mode, 2-minute cadence)
$sources = Get-Content -Raw 'config\sources.yaml'
$augment = Get-Content -Raw 'config\augmentor_config.yaml'
$rulesPath = 'config\rules.yaml'
$rules = if (Test-Path $rulesPath) { Get-Content -Raw $rulesPath } else { "" }

$configPayload = [ordered]@{
    sources_yaml             = [string]$sources
    augment_yaml             = [string]$augment
    rules_yaml               = [string]$rules
    pipeline_settings        = @{
        mode            = 'augment'
        output_path     = 'test_output_data/augment_output.json'
        persist_to_db   = $true
        timeout         = 15
        log_level       = 'INFO'
    }
    refresh_interval_minutes = 2
    created_by               = 'CLI demo'
} | ConvertTo-Json -Depth 6

$configResponse = Invoke-RestMethod `
    -Method Post `
    -Uri "$baseUrl/profiles/$profileId/configs" `
    -Headers $headers `
    -Body ([Text.Encoding]::UTF8.GetBytes($configPayload))

$configId = $configResponse.id

## 4b. Update an existing profile config (partial patch)
$configUpdate = @{
    refresh_interval_minutes = 5
    pipeline_settings        = @{
        mode          = 'augment'
        persist_to_db = $false
        timeout       = 20
    }
} | ConvertTo-Json -Depth 4

Invoke-RestMethod `
    -Method Patch `
    -Uri "$baseUrl/profiles/$profileId/configs/$configId" `
    -Headers $headers `
    -Body ([Text.Encoding]::UTF8.GetBytes($configUpdate))

## 5. Create a pipeline bound to the config
$pipelinePayload = @{
    profile_id        = $profileId
    profile_config_id = $configId
    name              = 'Acme Augment Pipeline'
    description       = 'Runs augment mode every 2 minutes'
    concurrency_limit = 1
    created_by        = 'CLI demo'
} | ConvertTo-Json -Depth 4

$pipelineResponse = Invoke-RestMethod `
    -Method Post `
    -Uri "$baseUrl/pipelines" `
    -Headers $headers `
    -Body ([Text.Encoding]::UTF8.GetBytes($pipelinePayload))

$pipelineId = $pipelineResponse.id

## 5b. Point a pipeline at a different config (must already exist)
# $newConfigId = 'replace-with-existing-config-guid'
# Invoke-RestMethod `
#     -Method Patch `
#     -Uri "$baseUrl/pipelines/$pipelineId/config" `
#     -Headers $headers `
#     -Body ([Text.Encoding]::UTF8.GetBytes((@{ profile_config_id = $newConfigId } | ConvertTo-Json)))

## 6. Kick off a run immediately
$runPayload = @{
    pipeline_id  = $pipelineId
    overrides    = @{ mode = 'augment' }  # optional; matches config default
    requested_by = 'CLI demo'
} | ConvertTo-Json -Depth 4

$runResponse = Invoke-RestMethod `
    -Method Post `
    -Uri "$baseUrl/runs" `
    -Headers $headers `
    -Body ([Text.Encoding]::UTF8.GetBytes($runPayload))

$runId = $runResponse.run_id

## 7. Monitor runs & jobs
# Detailed run status (artifacts, errors, metadata)
Invoke-RestMethod -Method Get -Uri "$baseUrl/runs/$runId" -Headers $headers

# Tail run logs (matches engine.log lines)
Invoke-RestMethod -Method Get -Uri "$baseUrl/runs/$runId/logs" -Headers $headers

# List latest runs for the profile
Invoke-RestMethod -Method Get -Uri "$baseUrl/runs?profile_id=$profileId" -Headers $headers

# Inspect background jobs the API is tracking
Invoke-RestMethod -Method Get -Uri "$baseUrl/jobs?profile_id=$profileId" -Headers $headers

## 8. List configs & pipelines now owned by the profile
Invoke-RestMethod -Method Get -Uri "$baseUrl/profiles/$profileId/configs" -Headers $headers
Invoke-RestMethod -Method Get -Uri "$baseUrl/pipelines" -Headers $headers

## 8b. Search for active pipelines hosting a specific indicator
Invoke-RestMethod `
    -Method Get `
    -Uri "$baseUrl/profiles/$profileId/pipelines/search?indicator=example.com" `
    -Headers $headers

## 9. Hosted EDL feeds (requires completed run + profile key)
$indicatorTypes = @('ipv4','ipv6','cidr','fqdn','url')
foreach ($type in $indicatorTypes) {
    Write-Host "`n===== $type feed ====="
    try {
        Invoke-WebRequest `
            -Uri "$baseUrl/pipelines/$pipelineId/edl/$type" `
            -Headers @{ 'X-API-Key' = $profileKey } `
            -UseBasicParsing | Select-Object -ExpandProperty Content
    } catch {
        Write-Warning "No hosted data for $type yet."
    }
}

## 10. Optional cleanup / verification
# Cancel a run
# Invoke-RestMethod -Method Post -Uri "$baseUrl/runs/$runId/cancel" -Headers $headers

# Delete (soft-delete) a pipeline
# Invoke-RestMethod -Method Delete -Uri "$baseUrl/pipelines/$pipelineId" -Headers $headers

# Health check (no auth required)
Invoke-RestMethod -Method Get -Uri "$baseUrl/health"
